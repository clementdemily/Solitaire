<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Solitaire -:  Fichier source de Solitaire.cpp</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Solitaire -
   &#160;<span id="projectnumber">1.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Généré par Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Page&#160;principale</span></a></li>
      <li><a href="namespaces.html"><span>Espaces&#160;de&#160;nommage</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Fichiers</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>Liste&#160;des&#160;fichiers</span></a></li>
      <li><a href="globals.html"><span>Membres&#160;de&#160;fichier</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Solitaire.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="_solitaire_8cpp.html">Aller à la documentation de ce fichier.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#include &quot;<a class="code" href="_solitaire_8h.html" title="Classe contenant la logique du jeu solitaire.">Solitaire.h</a>&quot;</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="keyword">namespace </span>tp 
<a name="l00004"></a>00004 {
<a name="l00008"></a><a class="code" href="classtp_1_1_solitaire.html#ad263c1a044bb4cfec377b093b0ad8a7c">00008</a>     <a class="code" href="classtp_1_1_solitaire.html#ad263c1a044bb4cfec377b093b0ad8a7c" title="Constructeur par dÃ©faut.">Solitaire::Solitaire</a>()
<a name="l00009"></a>00009     {
<a name="l00010"></a>00010       <a class="code" href="classtp_1_1_solitaire.html#ab6aa6a46fff5190914b2a5298c865411" title="mÃ©lange le paquet de carte, distribue les 7 colonnes de cartes, init les piles">_init</a>();
<a name="l00011"></a>00011     }
<a name="l00012"></a>00012 
<a name="l00016"></a><a class="code" href="classtp_1_1_solitaire.html#a929da768a9f23e04944336356ce1e12f">00016</a>     <a class="code" href="classtp_1_1_solitaire.html#ad263c1a044bb4cfec377b093b0ad8a7c" title="Constructeur par dÃ©faut.">Solitaire::Solitaire</a>(<span class="keyword">const</span> <a class="code" href="classtp_1_1_solitaire.html" title="Classe contenant la logique du jeu solitaire.">Solitaire</a>&amp; p_cp) <span class="keywordflow">throw</span>(std::bad_alloc)
<a name="l00017"></a>00017     {
<a name="l00018"></a>00018       m_talon = p_cp.m_talon;
<a name="l00019"></a>00019       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; 7; i++)
<a name="l00020"></a>00020         m_colonnes[i] = p_cp.m_colonnes[i];
<a name="l00021"></a>00021       for (<span class="keywordtype">int</span> i = 0 ; i &lt; 4; i++)
<a name="l00022"></a>00022         m_piles[i] = p_cp.m_piles[i];
<a name="l00023"></a>00023     }
<a name="l00024"></a>00024 
<a name="l00030"></a><a class="code" href="classtp_1_1_solitaire.html#abc6b3325a7432c1d782f3aa94c41e053">00030</a>     <a class="code" href="classtp_1_1_solitaire.html#abc6b3325a7432c1d782f3aa94c41e053" title="Destructeur.">Solitaire::~Solitaire</a>()
<a name="l00031"></a>00031     {
<a name="l00032"></a>00032     }
<a name="l00033"></a>00033     <span class="comment">//Surcharge d&#39;opÃ©rateurs</span>
<a name="l00034"></a>00034 
<a name="l00038"></a><a class="code" href="classtp_1_1_solitaire.html#afea2a2f2c4c79ceae168d2ddd101ab4d">00038</a>     <span class="keyword">const</span> <a class="code" href="classtp_1_1_solitaire.html" title="Classe contenant la logique du jeu solitaire.">Solitaire</a>&amp; <a class="code" href="classtp_1_1_solitaire.html#afea2a2f2c4c79ceae168d2ddd101ab4d" title="Surcharger l&#39;opÃ©rateur =.">Solitaire::operator = </a>(<span class="keyword">const</span> <a class="code" href="classtp_1_1_solitaire.html" title="Classe contenant la logique du jeu solitaire.">Solitaire</a>&amp; p_cp) <span class="keywordflow">throw</span> (std::bad_alloc)
<a name="l00039"></a>00039     {
<a name="l00040"></a>00040       m_talon = p_cp.<a class="code" href="classtp_1_1_solitaire.html#a0950928b601368dbdc8e04977dbb258a">m_talon</a>;
<a name="l00041"></a>00041       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; 7; i++)
<a name="l00042"></a>00042         m_colonnes[i] = p_cp.m_colonnes[i];
<a name="l00043"></a>00043       for (<span class="keywordtype">int</span> i = 0 ; i &lt; 4; i++)
<a name="l00044"></a>00044         m_piles[i] = p_cp.m_piles[i];
<a name="l00045"></a>00045 
<a name="l00046"></a>00046       return (*<span class="keyword">this</span>);
<a name="l00047"></a>00047     }
<a name="l00048"></a>00048 
<a name="l00054"></a><a class="code" href="namespacetp.html#ac148436fc8d147524e35e1cc79c88661">00054</a>     std::ostream&amp; <a class="code" href="namespacetp.html#a16b20d3d11bee4d1141c57e9e8df7aa8">operator &lt;&lt; </a>(std::ostream&amp; p_f, <span class="keyword">const</span> <a class="code" href="classtp_1_1_solitaire.html" title="Classe contenant la logique du jeu solitaire.">Solitaire</a>&amp; p_l)
<a name="l00055"></a>00055     {
<a name="l00056"></a>00056       (void)p_l;
<a name="l00057"></a>00057       p_f &lt;&lt; <span class="stringliteral">&quot;salut&quot;</span>;
<a name="l00058"></a>00058       <span class="keywordflow">return</span> (p_f);
<a name="l00059"></a>00059     }
<a name="l00060"></a>00060 
<a name="l00064"></a><a class="code" href="classtp_1_1_solitaire.html#a2b875a04664858ef9ba537e0e9b991db">00064</a>     <span class="keywordtype">void</span>  <a class="code" href="classtp_1_1_solitaire.html#a2b875a04664858ef9ba537e0e9b991db" title="Fait avancer le talon d&#39;une carte, c&#39;est-Ã -dire prend la premiÃ¨re et la place Ã  la fin du talon...">Solitaire::avancerTalon</a>()
<a name="l00065"></a>00065     {
<a name="l00066"></a>00066       <span class="keywordflow">if</span> (<a class="code" href="classtp_1_1_solitaire.html#a0950928b601368dbdc8e04977dbb258a">m_talon</a>.<a class="code" href="classtp_1_1_file.html#af248b9b110b4efeddcead5a3bec95919" title="Demander la taille de la File.">taille</a>() &gt; 1)
<a name="l00067"></a>00067       {
<a name="l00068"></a>00068         <a class="code" href="classtp_1_1_solitaire.html#a0950928b601368dbdc8e04977dbb258a">m_talon</a>.<a class="code" href="classtp_1_1_file.html#a064d1872300759ba8d458c8efd056dbc" title="Enfiler un nouvel Ã©lÃ©ment dans la file.">enfiler</a>(<a class="code" href="classtp_1_1_solitaire.html#a0950928b601368dbdc8e04977dbb258a">m_talon</a>.<a class="code" href="classtp_1_1_file.html#a5b4655946c237457837ac8793fde14c1" title="DÃ©filer un Ã©lÃ©ment.">defiler</a>());
<a name="l00069"></a>00069       }
<a name="l00070"></a>00070     }
<a name="l00071"></a>00071 
<a name="l00079"></a><a class="code" href="classtp_1_1_solitaire.html#a5174ea0b69bb089451c32d59114f2430">00079</a>     <span class="keywordtype">void</span>  <a class="code" href="classtp_1_1_solitaire.html#a5174ea0b69bb089451c32d59114f2430" title="DÃ©place p_nbCartes cartes Ã  partir de la colonne p_colonneSource vers la colonne p_colonneDestinati...">Solitaire::deplacerColonneAColonne</a>( <span class="keywordtype">int</span> p_colonneSource, <span class="keywordtype">int</span> p_colonneDestination, <span class="keywordtype">int</span> p_nbCartes) <span class="keywordflow">throw</span> (std::runtime_error)
<a name="l00080"></a>00080     {
<a name="l00081"></a>00081       <span class="keywordflow">if</span> (p_colonneSource &lt; 0 &amp;&amp; p_colonneSource &gt; 6)
<a name="l00082"></a>00082         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;deplacerColonneAColonne() : choix colonne source incorrect&quot;</span>);
<a name="l00083"></a>00083       <span class="keywordflow">if</span> (p_colonneDestination &lt; 0 &amp;&amp; p_colonneDestination &gt; 6)
<a name="l00084"></a>00084         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;deplacerColonneAColonne() : choix colonne destination incorrect&quot;</span>);
<a name="l00085"></a>00085 
<a name="l00086"></a>00086       m_colonnes[p_colonneSource].deplacePaquet(m_colonnes[p_colonneDestination], p_nbCartes);
<a name="l00087"></a>00087     }
<a name="l00088"></a>00088 
<a name="l00094"></a><a class="code" href="classtp_1_1_solitaire.html#adcdc5b2ff242cdcacdb4421f9e2c7671">00094</a>     <span class="keywordtype">void</span>  <a class="code" href="classtp_1_1_solitaire.html#adcdc5b2ff242cdcacdb4421f9e2c7671" title="DÃ©place la carte du dessus du talon vers la colonne spÃ©cifiÃ©e par &quot;p_colonneDestination&quot;.">Solitaire::deplacerTalonAColonne</a> ( <span class="keywordtype">int</span> p_colonneDestination ) <span class="keywordflow">throw</span> (std::runtime_error)
<a name="l00095"></a>00095     {
<a name="l00096"></a>00096       <span class="keywordflow">if</span> (p_colonneDestination &lt; 0 &amp;&amp; p_colonneDestination &gt; 6)
<a name="l00097"></a>00097         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;deplacerTalonAColonne() : choix colonne incorrect&quot;</span>);
<a name="l00098"></a>00098       <span class="keywordflow">if</span> (m_talon.taille() == 0)
<a name="l00099"></a>00099         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;deplacerTalonAColonne() : erreur talon&quot;</span>);
<a name="l00100"></a>00100 
<a name="l00101"></a>00101       m_colonnes[p_colonneDestination].ajoute(m_talon.premier());
<a name="l00102"></a>00102       m_talon.defiler();
<a name="l00103"></a>00103     }
<a name="l00104"></a>00104 
<a name="l00110"></a><a class="code" href="classtp_1_1_solitaire.html#a35fd87813f223fe41014fa3fd82dd99b">00110</a>     <span class="keywordtype">void</span>  <a class="code" href="classtp_1_1_solitaire.html#a35fd87813f223fe41014fa3fd82dd99b" title="DÃ©place la carte du dessus du talon vers la pile spÃ©cifiÃ©e par &quot;p_pileDestination&quot;.">Solitaire::deplacerTalonAPile</a> ( <span class="keywordtype">int</span> p_pileDestination ) <span class="keywordflow">throw</span> (std::runtime_error)
<a name="l00111"></a>00111     {
<a name="l00112"></a>00112       <span class="keywordflow">if</span> (p_pileDestination &lt; 0 &amp;&amp; p_pileDestination &gt; 6)
<a name="l00113"></a>00113         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;deplacerTalonAPile() : choix pile incorrect&quot;</span>);
<a name="l00114"></a>00114       <span class="keywordflow">if</span> (m_talon.taille() == 0)
<a name="l00115"></a>00115         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;deplacerTalonAColonne() : erreur talon&quot;</span>);
<a name="l00116"></a>00116 
<a name="l00117"></a>00117       <span class="keywordflow">if</span> (
<a name="l00118"></a>00118           (m_piles[p_pileDestination].taille() == 0 &amp;&amp; m_talon.premier().reqValeur() == <a class="code" href="namespacetp.html#a9711cb844f6ba84cf9c12047e1caee63a852cf209c2aca6614da2fb694fb3b9e6">AS</a>) ||
<a name="l00119"></a>00119           (m_piles[p_pileDestination].taille() &gt; 0 &amp;&amp; m_piles[p_pileDestination].premier().estSuivante(m_talon.premier()) )
<a name="l00120"></a>00120           ){
<a name="l00121"></a>00121         m_piles[p_pileDestination].empiler(m_talon.premier());
<a name="l00122"></a>00122         m_talon.defiler();
<a name="l00123"></a>00123       }
<a name="l00124"></a>00124       <span class="keywordflow">else</span>
<a name="l00125"></a>00125         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;deplacerTalonAPile() : valeur ou sorte de carte incorrect&quot;</span>);
<a name="l00126"></a>00126     }
<a name="l00127"></a>00127 
<a name="l00134"></a><a class="code" href="classtp_1_1_solitaire.html#a4fa6049bda7fa2851650b07473724b85">00134</a>     <span class="keywordtype">void</span>  <a class="code" href="classtp_1_1_solitaire.html#a4fa6049bda7fa2851650b07473724b85" title="DÃ©place la derniÃ¨re carte de la colonne spÃ©cifiÃ©e par &quot;p_colonneSource&quot; vers la pile spÃ©cifiÃ©e ...">Solitaire::deplacerColonneAPile</a> ( <span class="keywordtype">int</span> p_colonneSource, <span class="keywordtype">int</span> p_pileDestination) <span class="keywordflow">throw</span> (std::runtime_error)
<a name="l00135"></a>00135     {
<a name="l00136"></a>00136       <span class="keywordflow">if</span> (p_pileDestination &lt; 0 || p_pileDestination &gt; 3)
<a name="l00137"></a>00137         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;deplacerColonneAPile() : choix de pile incorrect&quot;</span>);
<a name="l00138"></a>00138       <span class="keywordflow">if</span> (p_colonneSource &lt; 0 || p_colonneSource &gt; 6)
<a name="l00139"></a>00139         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;deplacerColonneAPile() : choix de colonne incorrect&quot;</span>);
<a name="l00140"></a>00140 
<a name="l00141"></a>00141       <span class="keywordflow">if</span> ((m_piles[p_pileDestination].taille() == 0 &amp;&amp; m_colonnes[p_colonneSource].reqLesCartes().element(1).reqValeur() == <a class="code" href="namespacetp.html#a9711cb844f6ba84cf9c12047e1caee63a852cf209c2aca6614da2fb694fb3b9e6">AS</a>) ||
<a name="l00142"></a>00142           (m_piles[p_pileDestination].taille() &gt; 0 &amp;&amp; m_piles[p_pileDestination].premier().estSuivante(m_colonnes[p_colonneSource].reqLesCartes().element(1))))
<a name="l00143"></a>00143       {
<a name="l00144"></a>00144         m_piles[p_pileDestination].empiler(m_colonnes[p_colonneSource].reqLesCartes().element(1));
<a name="l00145"></a>00145         m_colonnes[p_colonneSource].supprimerDerniereCarte();
<a name="l00146"></a>00146       }
<a name="l00147"></a>00147       <span class="keywordflow">else</span>
<a name="l00148"></a>00148         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;deplacerColonneAPile() : deplacement incorrect&quot;</span>);
<a name="l00149"></a>00149     }
<a name="l00150"></a>00150     
<a name="l00155"></a><a class="code" href="classtp_1_1_solitaire.html#a960cfcc78d5c3f382f0dce963c36e1fa">00155</a>     <span class="keywordtype">bool</span>  <a class="code" href="classtp_1_1_solitaire.html#a960cfcc78d5c3f382f0dce963c36e1fa" title="VÃ©rifie si le joueur a gagnÃ©:">Solitaire::verifieGagne</a> ( )<span class="keyword"> const</span>
<a name="l00156"></a>00156 <span class="keyword">    </span>{
<a name="l00157"></a>00157       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; ++i)
<a name="l00158"></a>00158         <span class="keywordflow">if</span> (<a class="code" href="classtp_1_1_solitaire.html#a340b00efdee37a352fdc6ad3ccfce6ec">m_piles</a>[i].taille() &lt; 14)
<a name="l00159"></a>00159           <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00160"></a>00160       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00161"></a>00161     }
<a name="l00162"></a>00162 
<a name="l00167"></a><a class="code" href="classtp_1_1_solitaire.html#ae87fb5eaba1a2d45b9d3ff2eec99ce31">00167</a>     std::string <a class="code" href="classtp_1_1_solitaire.html#ae87fb5eaba1a2d45b9d3ff2eec99ce31" title="retourne l&#39;Ã©tat du jeu">Solitaire::reqEtatJeu</a> ( )<span class="keyword"> const</span>
<a name="l00168"></a>00168 <span class="keyword">    </span>{
<a name="l00169"></a>00169       std::stringstream etatJeu;
<a name="l00170"></a>00170 
<a name="l00171"></a>00171       etatJeu &lt;&lt; <span class="stringliteral">&quot;Talon: &quot;</span>;
<a name="l00172"></a>00172       <span class="keywordflow">if</span> (<a class="code" href="classtp_1_1_solitaire.html#a0950928b601368dbdc8e04977dbb258a">m_talon</a>.<a class="code" href="classtp_1_1_file.html#af248b9b110b4efeddcead5a3bec95919" title="Demander la taille de la File.">taille</a>() &gt; 0)
<a name="l00173"></a>00173         etatJeu &lt;&lt; <a class="code" href="classtp_1_1_solitaire.html#a0950928b601368dbdc8e04977dbb258a">m_talon</a>.<a class="code" href="classtp_1_1_file.html#a0a6e57c29029991d1c05c6cc5d67125c" title="Retourner l&#39;Ã©lÃ©ment au dÃ©but de la file.">premier</a>();
<a name="l00174"></a>00174       <span class="keywordflow">else</span>
<a name="l00175"></a>00175         etatJeu &lt;&lt; <span class="stringliteral">&quot;X&quot;</span>;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177       etatJeu &lt;&lt; <span class="stringliteral">&quot;\t\t\t\t&quot;</span>;
<a name="l00178"></a>00178 
<a name="l00179"></a>00179       etatJeu &lt;&lt; <span class="stringliteral">&quot;Piles&quot;</span>;
<a name="l00180"></a>00180       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; ++i)
<a name="l00181"></a>00181       {
<a name="l00182"></a>00182         etatJeu &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00183"></a>00183         <span class="keywordflow">if</span> (<a class="code" href="classtp_1_1_solitaire.html#a340b00efdee37a352fdc6ad3ccfce6ec">m_piles</a>[i].taille() &gt; 0)
<a name="l00184"></a>00184           etatJeu &lt;&lt; <a class="code" href="classtp_1_1_solitaire.html#a340b00efdee37a352fdc6ad3ccfce6ec">m_piles</a>[i].<a class="code" href="classtp_1_1_pile.html#a5e3af522de852d10ca20fa48196afbb9" title="Retourner l&#39;Ã©lÃ©ment au dÃ©but de la Pile.">premier</a>();
<a name="l00185"></a>00185         <span class="keywordflow">else</span>
<a name="l00186"></a>00186           etatJeu &lt;&lt; <span class="stringliteral">&quot;X&quot;</span>;
<a name="l00187"></a>00187       }
<a name="l00188"></a>00188       
<a name="l00189"></a>00189       etatJeu &lt;&lt; std::endl &lt;&lt; std::endl;
<a name="l00190"></a>00190 
<a name="l00191"></a>00191       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 7 ; ++i)
<a name="l00192"></a>00192       etatJeu &lt;&lt; <span class="stringliteral">&quot;Col.&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; <a class="code" href="classtp_1_1_solitaire.html#a37164cabd889226b3c7a3c52e8b26d32">m_colonnes</a>[i] &lt;&lt; std::endl;
<a name="l00193"></a>00193 
<a name="l00194"></a>00194       <span class="keywordflow">return</span> etatJeu.str();
<a name="l00195"></a>00195     }
<a name="l00196"></a>00196 
<a name="l00200"></a><a class="code" href="classtp_1_1_solitaire.html#ab6aa6a46fff5190914b2a5298c865411">00200</a>     <span class="keywordtype">void</span>  <a class="code" href="classtp_1_1_solitaire.html#ab6aa6a46fff5190914b2a5298c865411" title="mÃ©lange le paquet de carte, distribue les 7 colonnes de cartes, init les piles">Solitaire::_init</a>()
<a name="l00201"></a>00201     {
<a name="l00202"></a>00202       <span class="keywordflow">try</span> {
<a name="l00203"></a>00203         <a class="code" href="classtp_1_1_solitaire.html#ae6281ea0a9bb5ff9b299ee8beae03a7f" title="initialise les cartes du talon">_initTalon</a>();
<a name="l00204"></a>00204         <a class="code" href="classtp_1_1_solitaire.html#ac8d2d6b4e07802655cb39f3c194b73bf" title="initialise les cartes du talon">_initColonnes</a>();
<a name="l00205"></a>00205       } <span class="keywordflow">catch</span> (std::exception &amp; e)
<a name="l00206"></a>00206       {
<a name="l00207"></a>00207         std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
<a name="l00208"></a>00208         <span class="keywordflow">throw</span>;
<a name="l00209"></a>00209       }
<a name="l00210"></a>00210     }
<a name="l00211"></a>00211 
<a name="l00215"></a><a class="code" href="classtp_1_1_solitaire.html#a7708bec6b316c80f4fdc04bab273a8ff">00215</a>     <span class="keywordtype">void</span>  <a class="code" href="classtp_1_1_solitaire.html#a7708bec6b316c80f4fdc04bab273a8ff" title="RÃ©alise une copie profonde d&#39;un solitaire.">Solitaire::_copie</a>(<span class="keyword">const</span> <a class="code" href="classtp_1_1_solitaire.html" title="Classe contenant la logique du jeu solitaire.">Solitaire</a>&amp; p_cp)
<a name="l00216"></a>00216     {
<a name="l00217"></a>00217 
<a name="l00218"></a>00218     }
<a name="l00219"></a>00219 
<a name="l00223"></a><a class="code" href="classtp_1_1_solitaire.html#ae5e58795dafc6814dfc63cb5895e691e">00223</a>     <span class="keywordtype">void</span>  <a class="code" href="classtp_1_1_solitaire.html#ae5e58795dafc6814dfc63cb5895e691e" title="DÃ©truit l&#39;objet.">Solitaire::_detruire</a>()
<a name="l00224"></a>00224     {
<a name="l00225"></a>00225 
<a name="l00226"></a>00226     }
<a name="l00227"></a>00227 
<a name="l00231"></a><a class="code" href="classtp_1_1_solitaire.html#ae6281ea0a9bb5ff9b299ee8beae03a7f">00231</a>     <span class="keywordtype">void</span>  <a class="code" href="classtp_1_1_solitaire.html#ae6281ea0a9bb5ff9b299ee8beae03a7f" title="initialise les cartes du talon">Solitaire::_initTalon</a>()
<a name="l00232"></a>00232     {
<a name="l00233"></a>00233       std::vector&lt;Carte&gt; v;
<a name="l00234"></a>00234       std::srand ( <span class="keywordtype">unsigned</span> ( std::time(0) ) );
<a name="l00235"></a>00235 
<a name="l00236"></a>00236       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; 4 ; i++)
<a name="l00237"></a>00237       {
<a name="l00238"></a>00238         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0 ; j &lt; 13 ; j++)
<a name="l00239"></a>00239         {
<a name="l00240"></a>00240           <a class="code" href="classtp_1_1_carte.html" title="classe representant une carte a jouer">Carte</a> nouvelleCarte((<a class="code" href="namespacetp.html#a46438f6a7b34ccc4c4d81b986aa5c3fe" title="la sorte de la carte">Sorte</a>)i, (<a class="code" href="namespacetp.html#a9711cb844f6ba84cf9c12047e1caee63" title="la valeur de la carte">Valeur</a>)j);
<a name="l00241"></a>00241           v.push_back(nouvelleCarte);
<a name="l00242"></a>00242         }
<a name="l00243"></a>00243       }
<a name="l00244"></a>00244 
<a name="l00245"></a>00245       std::random_shuffle ( v.begin(), v.end() );
<a name="l00246"></a>00246 
<a name="l00247"></a>00247       <span class="keywordflow">for</span> (std::vector&lt;Carte&gt;::iterator it = v.begin(); it &lt; v.end() ; it++)
<a name="l00248"></a>00248         <a class="code" href="classtp_1_1_solitaire.html#a0950928b601368dbdc8e04977dbb258a">m_talon</a>.<a class="code" href="classtp_1_1_file.html#a064d1872300759ba8d458c8efd056dbc" title="Enfiler un nouvel Ã©lÃ©ment dans la file.">enfiler</a>(*it);
<a name="l00249"></a>00249     }
<a name="l00250"></a>00250 
<a name="l00254"></a><a class="code" href="classtp_1_1_solitaire.html#ac8d2d6b4e07802655cb39f3c194b73bf">00254</a>     <span class="keywordtype">void</span>  <a class="code" href="classtp_1_1_solitaire.html#ac8d2d6b4e07802655cb39f3c194b73bf" title="initialise les cartes du talon">Solitaire::_initColonnes</a>()
<a name="l00255"></a>00255     {
<a name="l00256"></a>00256       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; 7 ; i++)
<a name="l00257"></a>00257       {
<a name="l00258"></a>00258         <a class="code" href="classtp_1_1_liste.html">Liste&lt;Carte&gt;</a> colonne;
<a name="l00259"></a>00259 
<a name="l00260"></a>00260         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0 ; j &lt;= i; j++)
<a name="l00261"></a>00261         {
<a name="l00262"></a>00262           colonne.<a class="code" href="classtp_1_1_liste.html#a31eb4dbcd4801fdb7b30b3e25de288bb">ajouter</a>(<a class="code" href="classtp_1_1_solitaire.html#a0950928b601368dbdc8e04977dbb258a">m_talon</a>.<a class="code" href="classtp_1_1_file.html#a5b4655946c237457837ac8793fde14c1" title="DÃ©filer un Ã©lÃ©ment.">defiler</a>(), 1);
<a name="l00263"></a>00263         }
<a name="l00264"></a>00264         <a class="code" href="classtp_1_1_solitaire.html#a37164cabd889226b3c7a3c52e8b26d32">m_colonnes</a>[i].<a class="code" href="classtp_1_1_colonne_cartes.html#a59a342c472518f4d1c15b432b99141f2">initColonneCartes</a>(colonne);
<a name="l00265"></a>00265       }
<a name="l00266"></a>00266     }
<a name="l00267"></a>00267 }
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Généré le Jeudi Octobre 3 2013 11:19:33 pour Solitaire - par &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
